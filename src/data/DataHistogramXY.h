/*!
* \file DataHistogramXY.h
* \author Marco Cattani <m.cattani@icloud.com>
* \version 3.0
* \date 26/02/2022
* \brief 
* \remarks None
* 
* 
* 
*/

/** \addtogroup Data
 *  @{
 */

#ifndef GRAFICI_DATA_HISTOGRAM_XY_H
#define GRAFICI_DATA_HISTOGRAM_XY_H

/*! Importation of librairies*/
#include "DataSelect.h"
#include "DataVector.h"

/**
 * @brief Vector data source generated by counting the frequencies of data points from a given data source
 * 
 * @tparam BINS Number of frequency bins to subdivide the data point space 
 *
 */
template <size_t BINS>
class DataHistogramXY : public DataSource<DataVector>
{
  public:
	/* To plot multiple n bar plots, use num_classes = n and use n of this classes for the x axis.
	 Each class with class_id [0, n-1] */
	DataHistogramXY(const DataSourceNorm &source, bool normalized = false, size_t class_id = 0, size_t num_classes = 1)
	    : DataSource<DataVector>{ BINS }
	    , _source{ source }
	    , _normalized{ normalized }
	    , _class_id{ class_id }
	    , _num_classes{ num_classes }
	{
		compute_histogram();
	}

	const DataVector operator[](const unsigned long idx) const
	{
		if (idx < size())
		{
			if (_normalized)
				return {
					{ static_cast<float>(0.5 + idx * _num_classes + _class_id), { 0.0, static_cast<float>(size() * _num_classes) } },
					{ static_cast<float>(_bins[idx]) / static_cast<float>(_total), { 0, 1 } },
				};
			else
				return {
					{ static_cast<float>(0.5 + idx * _num_classes + _class_id), { 0.0, static_cast<float>(size() * _num_classes) } },
					{ static_cast<float>(_bins[idx]), _histogram_y_range },
				};
		}
		else
		{
			return INVALID_DATA_VECTOR;
		}
	}

	/* methods to get a datasource from the interpolated dataset */
	DataSelect x() const
	{
		return DataSelect(*this, VectorComponents::x);
	}

	DataSelect y() const
	{
		return DataSelect(*this, VectorComponents::y);
	}

  private:
	void compute_histogram()
	{
		memset(_bins, 0, sizeof(_bins));
		_histogram_y_range = { 0, 0 };
		_total = 0;
		for (size_t idx = 0; idx < _source.size(); ++idx)
		{
			/* TODO add possiblity to define custom bucket range using a Range */
			size_t bin_idx = floor(_source[idx].norm() * size());
			if (bin_idx == size())
			{
				bin_idx--;
			}
			_bins[bin_idx]++;
			_total++;
			_histogram_y_range.update(_bins[bin_idx]);
		}
	}

	const DataSourceNorm &_source;
	bool _normalized;
	size_t _total;
	size_t _class_id;
	size_t _num_classes;
	size_t _bins[BINS]{ 0 };
	Range<float> _histogram_y_range{ 0, 0 };
};

#endif //GRAFICI_DATA_HISTOGRAM_XY_H

/** @}*/