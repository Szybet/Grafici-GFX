/*!
* \file DataInterpolatorL.h
* \author Marco Cattani <m.cattani@icloud.com>
* \version 3.0
* \date 26/02/2022
* \brief 
* \remarks None
* 
* 
* 
*/

/** \addtogroup Data
 *  @{
 */

#ifndef GRAFICI_DATA_LINEAR_INTERPOLATOR_H
#define GRAFICI_DATA_LINEAR_INTERPOLATOR_H

/*! Importation of librairies*/
#include "DataSelect.h"
#include "DataVector.h"

/**
 * @brief Vector data source vector generated by interpolating the data point of a give data source
 * 
 */
class DataInterpolatorL : public DataSource<DataVector>
{
  public:
	DataInterpolatorL(const DataSourceNorm &x, const DataSourceNorm &y, size_t interpolationSteps)
	    : DataSource<DataVector>{ interpolationSteps }
	    , _x{ x }
	    , _y{ y }
	    , _src_size{ DataSourceNorm::min_data_source_size(x, y) }
	    , _indexRange{ 0, interpolationSteps }
	{
	}

	const DataVector operator[](const unsigned long idx) const
	{
		if (idx < size())
		{
			size_t bin;
			float norm_bin_weight;

			compute_x_bin(idx, &bin, &norm_bin_weight);

			/* compute the raw range for the right bin on x and y*/
			Range<float> rawBinRangeX{ _x[bin].raw(), _x[bin + 1].raw() };
			Range<float> rawBinRangeY{ _y[bin].raw(), _y[bin + 1].raw() };

			/* interpolate x and y by mapping the normalized bin weight over the raw bin ranges */
			/* note that we compute the normBinWeight on the x axis and interpolate on the y axis */
			return {
				{ rawBinRangeX.norm_to_value(norm_bin_weight), _x.range() },
				{ rawBinRangeY.norm_to_value(norm_bin_weight), _y.range() },
			};
		}
		else
		{
			return INVALID_DATA_VECTOR;
		}
	}

	/* methods to get a datasource from the interpolated dataset */
	virtual DataSelect x() const
	{
		return DataSelect(*this, VectorComponents::x);
	}

	virtual DataSelect y() const
	{
		return DataSelect(*this, VectorComponents::y);
	}

  protected:
	const DataSourceNorm &_x;
	const DataSourceNorm &_y;
	size_t _src_size;
	Range<size_t> _indexRange{ 0, 0 };

	void compute_x_bin(const unsigned long idx, size_t *bin, float *norm_bin_weight) const
	{
		*bin = 0;
		*norm_bin_weight = 1.0;

		/* search for the normalized x bin containing the normalized idx */
		while (*bin < _src_size - 1)
		{
			/* compute the normalized inter-bin range for the x source */
			Range<float> normBinRangeX = { _x[*bin].norm(), _x[*bin + 1].norm() };

			/* compute the normalized index */
			float normIndex = _indexRange.value_to_norm(idx);
			/* compute the normalized position inside the bin (in case we found the right one or we are out of range)*/
			*norm_bin_weight = normBinRangeX.value_to_norm(normIndex);
			/* if the normalized index is inside the normalized bin range (on x), then stop */
			if (normBinRangeX.contains(normIndex))
			{
				return;
			}
			else
			{
				(*bin)++;
			}
		}
	}
};

#endif /* GRAFICI_DATA_LINEAR_INTERPOLATOR_H */

/** @}*/